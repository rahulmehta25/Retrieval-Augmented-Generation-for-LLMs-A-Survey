name: Deploy to Production

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: ${{ github.repository }}/rag-backend
  IMAGE_NAME_FRONTEND: ${{ github.repository }}/rag-frontend

jobs:
  build-and-push:
    name: Build and Push Production Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write

    outputs:
      backend-image: ${{ steps.meta-backend.outputs.tags }}
      frontend-image: ${{ steps.meta-frontend.outputs.tags }}
      backend-digest: ${{ steps.build-backend.outputs.digest }}
      frontend-digest: ${{ steps.build-frontend.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Backend production build
      - name: Extract metadata for backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=sha,prefix={{branch}}-
            type=raw,value=stable,enable={{is_default_branch}}

      - name: Build and push backend image
        id: build-backend
        uses: docker/build-push-action@v5
        with:
          context: ./rag-from-scratch
          file: ./rag-from-scratch/Dockerfile.prod
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
          build-args: |
            BUILD_ENV=production

      # Frontend production build
      - name: Extract metadata for frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=sha,prefix={{branch}}-
            type=raw,value=stable,enable={{is_default_branch}}

      - name: Build and push frontend image
        id: build-frontend
        uses: docker/build-push-action@v5
        with:
          context: ./glass-scroll-scribe
          file: ./glass-scroll-scribe/Dockerfile.prod
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
          build-args: |
            BUILD_ENV=production

      # Security scanning of production images
      - name: Run Trivy vulnerability scanner on backend
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.meta-backend.outputs.tags }}
          format: 'sarif'
          output: 'backend-trivy-results.sarif'

      - name: Run Trivy vulnerability scanner on frontend
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.meta-frontend.outputs.tags }}
          format: 'sarif'
          output: 'frontend-trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: '.'

  deploy-to-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    environment:
      name: staging
      url: https://rag-staging.your-domain.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure kubectl for staging
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_STAGING }}

      - name: Deploy to staging with blue-green
        run: |
          # Determine current and new environment colors
          CURRENT_COLOR=$(kubectl get svc rag-app-active -n rag-staging -o jsonpath='{.spec.selector.color}' 2>/dev/null || echo "blue")
          NEW_COLOR=$([ "$CURRENT_COLOR" = "blue" ] && echo "green" || echo "blue")
          
          echo "Current color: $CURRENT_COLOR, New color: $NEW_COLOR"
          
          # Update image tags for new color deployment
          sed -i "s|BACKEND_IMAGE_TAG|${{ needs.build-and-push.outputs.backend-image }}|g" k8s/overlays/staging/kustomization.yml
          sed -i "s|FRONTEND_IMAGE_TAG|${{ needs.build-and-push.outputs.frontend-image }}|g" k8s/overlays/staging/kustomization.yml
          sed -i "s|COLOR_LABEL|$NEW_COLOR|g" k8s/overlays/staging/kustomization.yml
          
          # Deploy to new color environment
          kubectl apply -k k8s/overlays/staging/
          
          # Wait for new deployment to be ready
          kubectl rollout status deployment/rag-backend-$NEW_COLOR -n rag-staging --timeout=600s
          kubectl rollout status deployment/rag-frontend-$NEW_COLOR -n rag-staging --timeout=600s

      - name: Run comprehensive tests on staging
        run: |
          # Get new environment URLs
          NEW_COLOR=$(kubectl get svc rag-app-active -n rag-staging -o jsonpath='{.spec.selector.color}' 2>/dev/null || echo "blue")
          NEW_COLOR=$([ "$NEW_COLOR" = "blue" ] && echo "green" || echo "blue")
          
          BACKEND_URL=$(kubectl get svc rag-backend-$NEW_COLOR -n rag-staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          FRONTEND_URL=$(kubectl get svc rag-frontend-$NEW_COLOR -n rag-staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          # Health checks
          echo "Running health checks..."
          curl -f http://$BACKEND_URL:8000/health || exit 1
          curl -f http://$FRONTEND_URL:3000 || exit 1
          
          # API integration tests
          echo "Running API tests..."
          python -m pytest tests/integration/ --staging-url=http://$BACKEND_URL:8000 || exit 1
          
          # Performance tests
          echo "Running performance tests..."
          k6 run --env BASE_URL=http://$BACKEND_URL:8000 tests/performance/load-test.js || exit 1

      - name: Switch traffic to new deployment
        run: |
          # Get current and new colors
          CURRENT_COLOR=$(kubectl get svc rag-app-active -n rag-staging -o jsonpath='{.spec.selector.color}' 2>/dev/null || echo "blue")
          NEW_COLOR=$([ "$CURRENT_COLOR" = "blue" ] && echo "green" || echo "blue")
          
          # Switch active service to new color
          kubectl patch svc rag-app-active -n rag-staging -p '{"spec":{"selector":{"color":"'$NEW_COLOR'"}}}'
          
          echo "Traffic switched to $NEW_COLOR environment"

      - name: Cleanup old deployment
        run: |
          # Wait a bit to ensure traffic switch is stable
          sleep 30
          
          # Get old color
          CURRENT_COLOR=$(kubectl get svc rag-app-active -n rag-staging -o jsonpath='{.spec.selector.color}')
          OLD_COLOR=$([ "$CURRENT_COLOR" = "blue" ] && echo "green" || echo "blue")
          
          # Scale down old deployment
          kubectl scale deployment rag-backend-$OLD_COLOR --replicas=0 -n rag-staging
          kubectl scale deployment rag-frontend-$OLD_COLOR --replicas=0 -n rag-staging

  deploy-to-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-staging]
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')
    environment:
      name: production
      url: https://rag.your-domain.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure kubectl for production
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG_PROD }}

      - name: Pre-deployment validation
        run: |
          # Validate staging environment is healthy
          echo "Validating staging environment..."
          curl -f https://rag-staging.your-domain.com/health || exit 1
          
          # Check if there are any critical alerts
          # This would integrate with your monitoring system
          echo "Checking for critical alerts..."

      - name: Deploy to production with blue-green
        run: |
          # Determine current and new environment colors
          CURRENT_COLOR=$(kubectl get svc rag-app-active -n rag-prod -o jsonpath='{.spec.selector.color}' 2>/dev/null || echo "blue")
          NEW_COLOR=$([ "$CURRENT_COLOR" = "blue" ] && echo "green" || echo "blue")
          
          echo "Production deployment: $CURRENT_COLOR -> $NEW_COLOR"
          
          # Update image tags for new color deployment
          sed -i "s|BACKEND_IMAGE_TAG|${{ needs.build-and-push.outputs.backend-image }}|g" k8s/overlays/production/kustomization.yml
          sed -i "s|FRONTEND_IMAGE_TAG|${{ needs.build-and-push.outputs.frontend-image }}|g" k8s/overlays/production/kustomization.yml
          sed -i "s|COLOR_LABEL|$NEW_COLOR|g" k8s/overlays/production/kustomization.yml
          
          # Deploy to new color environment
          kubectl apply -k k8s/overlays/production/
          
          # Wait for new deployment to be ready
          kubectl rollout status deployment/rag-backend-$NEW_COLOR -n rag-prod --timeout=900s
          kubectl rollout status deployment/rag-frontend-$NEW_COLOR -n rag-prod --timeout=900s

      - name: Production smoke tests
        run: |
          # Get new environment details
          CURRENT_COLOR=$(kubectl get svc rag-app-active -n rag-prod -o jsonpath='{.spec.selector.color}' 2>/dev/null || echo "blue")
          NEW_COLOR=$([ "$CURRENT_COLOR" = "blue" ] && echo "green" || echo "blue")
          
          BACKEND_URL=$(kubectl get svc rag-backend-$NEW_COLOR -n rag-prod -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          # Critical path tests
          echo "Running production smoke tests..."
          curl -f http://$BACKEND_URL:8000/health || exit 1
          curl -f http://$BACKEND_URL:8000/metrics || exit 1
          
          # Test core RAG functionality
          python tests/production/smoke_test.py --url=http://$BACKEND_URL:8000 || exit 1

      - name: Gradual traffic switch
        run: |
          # Get current and new colors
          CURRENT_COLOR=$(kubectl get svc rag-app-active -n rag-prod -o jsonpath='{.spec.selector.color}' 2>/dev/null || echo "blue")
          NEW_COLOR=$([ "$CURRENT_COLOR" = "blue" ] && echo "green" || echo "blue")
          
          # Gradual traffic switch: 10% -> 50% -> 100%
          echo "Switching 10% traffic to $NEW_COLOR..."
          kubectl patch svc rag-app-canary -n rag-prod -p '{"spec":{"selector":{"color":"'$NEW_COLOR'"}}}'
          
          sleep 120  # Monitor for 2 minutes
          
          echo "Switching 50% traffic to $NEW_COLOR..."
          # This would require a more sophisticated traffic splitting solution like Istio
          
          sleep 300  # Monitor for 5 minutes
          
          echo "Switching 100% traffic to $NEW_COLOR..."
          kubectl patch svc rag-app-active -n rag-prod -p '{"spec":{"selector":{"color":"'$NEW_COLOR'"}}}'

      - name: Post-deployment monitoring
        run: |
          echo "Monitoring deployment for 10 minutes..."
          sleep 600
          
          # Check error rates and performance metrics
          # This would integrate with your monitoring system (Prometheus, DataDog, etc.)
          echo "Checking post-deployment metrics..."

      - name: Cleanup and finalize
        if: success()
        run: |
          # Scale down old deployment after successful switch
          CURRENT_COLOR=$(kubectl get svc rag-app-active -n rag-prod -o jsonpath='{.spec.selector.color}')
          OLD_COLOR=$([ "$CURRENT_COLOR" = "blue" ] && echo "green" || echo "blue")
          
          kubectl scale deployment rag-backend-$OLD_COLOR --replicas=1 -n rag-prod  # Keep 1 replica for quick rollback
          kubectl scale deployment rag-frontend-$OLD_COLOR --replicas=1 -n rag-prod

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed, initiating rollback..."
          
          # Get current colors
          CURRENT_COLOR=$(kubectl get svc rag-app-active -n rag-prod -o jsonpath='{.spec.selector.color}')
          ROLLBACK_COLOR=$([ "$CURRENT_COLOR" = "blue" ] && echo "green" || echo "blue")
          
          # Switch back to previous version
          kubectl patch svc rag-app-active -n rag-prod -p '{"spec":{"selector":{"color":"'$ROLLBACK_COLOR'"}}}'
          
          # Scale up rollback deployment if needed
          kubectl scale deployment rag-backend-$ROLLBACK_COLOR --replicas=3 -n rag-prod
          kubectl scale deployment rag-frontend-$ROLLBACK_COLOR --replicas=3 -n rag-prod
          
          echo "Rollback completed to $ROLLBACK_COLOR environment"

  notify-production-deployment:
    name: Notify Production Deployment
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-staging, deploy-to-production]
    if: always()

    steps:
      - name: Send comprehensive notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ needs.deploy-to-production.result }}
          channel: '#production-deployments'
          text: |
            🚀 **Production Deployment Complete**
            
            **Status:** ${{ needs.deploy-to-production.result == 'success' && '✅ SUCCESS' || '❌ FAILED' }}
            
            **Details:**
            • Environment: Production
            • Images: 
              - Backend: ${{ needs.build-and-push.outputs.backend-image }}
              - Frontend: ${{ needs.build-and-push.outputs.frontend-image }}
            • Commit: ${{ github.sha }}
            • Author: ${{ github.actor }}
            • Ref: ${{ github.ref }}
            
            **Links:**
            • Production: https://rag.your-domain.com
            • Monitoring: https://monitoring.your-domain.com
            • Logs: https://logs.your-domain.com
            
            ${{ needs.deploy-to-production.result == 'failure' && '🔴 **IMMEDIATE ACTION REQUIRED**' || '' }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_PROD }}